#!/usr/bin/env node

//
// Fuck you Curse.
// why did I have to do this?
// why couldn't you have just 
// done what you promised (a Linux client) years ago?
// instead I have to do this shit
// because you're too fucking lazy to!
// 
// as I said before, fuck you, Curse.
//
// Anyways, this is a modpack downloader
// that doesn't suck.. and actually works. 
// Well, I tried not to make it suck, at least.
// At least give me that.

const fs = require("fs");
const sr = require('sync-request');

const ErrorObjSchema = {
	error: ""
};

const FORGE_MP_API_ROOT = "https://addons-ecs.forgesvc.net/api/v2/";

const curseAPI = {
	GetModInfo: (id) => {
		var response = sr("GET", FORGE_MP_API_ROOT + "addon/" + id);

		if(response.statusCode != 200) { 
			var o = Object.create(ErrorObjSchema);
			o.error = "could not GET mod information for modpack ID " + id;
			return o;
		}
		return JSON.parse(response.getBody('utf8'));
	},

	DownloadFile: (modFileEntry) => {
		var response = sr("GET", modFileEntry.downloadUrl);
		if(response.statusCode != 200) { 
			var o = Object.create(ErrorObjSchema);
			o.error = "could not GET the file :(";
			return o;
		}
		return response.getBody();
	},
	IsError: (o) => {
		return (o.error != undefined || o.error != null);
	}
}

var av = process.argv.slice(1); // don't need node
var downloadDir = "";
var packfileId = "";

// [] == required
// <> == optional but can be passed
if(av[1] == undefined || av[1] == "--help") {
	process.stdout.write("curse modpack downloader by modeco80\n");
	process.stdout.write("usage: " + av[0] + " [curse modpack ID] <modpack file ID> <directory>\n");
	process.exit(0);
}

if(av[2] != undefined)
	packfileId = av[2];

if(av[3] == undefined) {
	if(packfileId != "")
		downloadDir = "modpack-" + av[1] + "-" + packfileId;
	else
		downloadDir = "modpack-" + av[1];
} else {
	downloadDir = av[3];
}

// The fun stuff starts here

console.log('making directory ' + downloadDir + ' for modpack id ' + av[1]);
try {
	fs.mkdirSync(downloadDir);
	fs.mkdirSync(downloadDir + '/' + 'mods');
} catch {
	console.log('continuing using existing directory tree');
}

var modinfo = curseAPI.GetModInfo(av[1]);

if(curseAPI.IsError(modinfo)) {
	console.log("Error: " + modinfo.error);
	process.exit(1);
}

if(modinfo.gameSlug != 'minecraft') {
	console.log("Not a Minecraft modpack");
	process.exit(1);
}

console.log('Modpack name ' + modinfo.name);

// "" == just use latest
if(packfileId == "") {
	packfileId = modinfo.latestFiles[modinfo.latestFiles.length - 1].id;
}

console.log("downloading (file ID) " + packfileId);
var buf = curseAPI.DownloadFile(packfileId);

if(curseAPI.IsError(buf)) {
	console.log("Error: " + modinfo.error);
	process.exit(1);
}

var zip = new require('node-zip')(buf, { base64: false, checkCRC32: true });
console.log("Downloaded modpack ZIP.");

// iterate through manifest.json
var manifest = JSON.parse(zip.files['manifest.json']._data);

for(var i = 0; i < manifest.files.length; ++i) {
	// Get all the mods
	var ti = curseAPI.GetModInfo(manifest.files[i].projectID);
	if(curseAPI.IsError(modinfo)) {
		console.log("Error: " + modinfo.error);
		process.exit(1);
	}

	ti.latestFiles.forEach((it) => {
		if(it.id === manifest.files[i].fileID) {
			var path = downloadDir + '/' + 'mods' + '/' + it.downloadUrl.split('/')[6];
			console.log("Downloading " + it.id);

			// A really bad caching solution.
			// Hopefully Curse(d) appreciates it
			if(!fs.existsSync(path)) { 
				var buf = curseAPI.DownloadFile(it);
				if(curseAPI.IsError(buf)) {
					console.log("Error: " + modinfo.error);
					process.exit(1);
				}
				// write the resulting buffer out
				console.log("Resulting path: " + path);
				fs.writeFileSync(path, buf, 'binary');
			} else {
				console.log("Cache found file");
			}
		}		
	});
}

console.log("Finished grabbing mods, extracting overrides folder");

// Extract everything from the modpack ZIP's overrides folder
Object.keys(zip.files).forEach((key) => {
	if(key.indexOf("overrides") != -1) {
		var slicedkey = key.slice("overrides".length);
		if(slicedkey.slice(-1) == "/") {
			if(!fs.existsSync(downloadDir + slicedkey)) {
				try {
					fs.mkdirSync(downloadDir + slicedkey);
				} catch {
				}
			}
			return;
		}
		console.log("Writing " + downloadDir + slicedkey + "...");
		fs.writeFileSync(downloadDir + slicedkey, zip.files[key]._data, 'binary');
	}
});
