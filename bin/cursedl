#!/usr/bin/env node

//
// Fuck you Curse.
// why did I have to do this?
// why couldn't you have just 
// done what you promised (a Linux client) years ago?
// instead I have to do this shit
// becuse you're too fucking lazy to!
// 
// as I said before, fuck you, Curse.
//
// Anyways, this is a modpack downloader
// that doesn't suck.. and actually works. 
// Well, I tried not to make it suck, at least.
// At least give me that.

const fs = require("fs");
const sr = require('sync-request');

const ErrorObjSchema = {
	error: ""
};

const FORGE_MP_API_ROOT = "https://addons-ecs.forgesvc.net/api/v2/";

const curseAPI = {
	GetModInfo: (id) => {
		var response = sr("GET", FORGE_MP_API_ROOT + "addon/" + id);

		if(response.statusCode != 200) { 
			var o = Object.create(ErrorObjSchema);
			o.error = "could not GET mod information for modpack ID " + id;
			return o;
		}
		return JSON.parse(response.getBody('utf8'));
	},

	DownloadFile: (modFileEntry) => {
		var response = sr("GET", modFileEntry.downloadUrl);
		if(response.statusCode != 200) { 
			var o = Object.create(ErrorObjSchema);
			o.error = "could not GET the file :(";
			return o;
		}
		return response.getBody();
	},
	IsError: (o) => {
		return (o.error != undefined || o.error != null);
	}
}

var av = process.argv.slice(1); // don't need node
var downloadDir = "";

if(av[1] == undefined || av[1] == "--help") {
	process.stdout.write("curse modpack downloader by modeco80\n");
	process.stdout.write("usage: " + av[0] + " [curse modpack ID] [directory]\n");
	process.exit(0);
}


// download dir checking
if(av[2] == undefined)
	downloadDir = "modpack-" + av[1];
else
	downloadDir = av[2];

// begin to download
console.log('making directory ' + downloadDir + ' for modpack id ' + av[1]);
try {
	fs.mkdirSync(downloadDir);
	fs.mkdirSync(downloadDir + '/' + 'mods');
} catch {
	console.log('continuing using existing directory tree');
}

var modinfo = curseAPI.GetModInfo(av[1]);

if(curseAPI.IsError(modinfo)) {
	console.log("Error: " + modinfo.error);
	process.exit(1);
}
//console.log(modinfo);

if(modinfo.gameSlug != 'minecraft') {
	console.log("Not a Minecraft modpack");
	process.exit(1);
}

console.log('Modpack name ' + modinfo.name);


console.log("downloading (file ID) " + modinfo.latestFiles[modinfo.latestFiles.length - 1].id);
var zip = new require('node-zip')(curseAPI.DownloadFile(modinfo.latestFiles[modinfo.latestFiles.length - 1]), {base64: false, checkCRC32: true});

if(curseAPI.IsError(zip)) {
	console.log("Error: " + modinfo.error);
	process.exit(1);
}

console.log("Got it!");

// iterate through manifest.json

var manifest = JSON.parse(zip.files['manifest.json']._data);
//console.log(manifest);
for(var i = 0; i < manifest.files.length; ++i) {
	// Get all the mods
	var ti = curseAPI.GetModInfo(manifest.files[i].projectID);
	if(curseAPI.IsError(modinfo)) {
		console.log("Error: " + modinfo.error);
		process.exit(1);
	}

	ti.latestFiles.forEach((it) => {
		if(it.id === manifest.files[i].fileID) {
			var path = downloadDir + '/' + 'mods' + '/' + it.downloadUrl.split('/')[6];
			console.log("Downloading " + it.id);

			// A really bad caching solution.
			// Hopefully Curse(d) appreciates it
			if(!fs.existsSync(path)) { 
				var buf = curseAPI.DownloadFile(it);
				// write the resulting buffer out

				console.log("Resulting path: " + path);
				fs.writeFileSync(path, buf, 'binary');
			} else {
				console.log("Shoddy cache found mod file so we aren't downloading it again");
			}
		}		
	});
}

console.log("Finished grabbing mods, extracting overrides folder");

// the nice thing is that the zip is all in memory so this will be pretty fast
Object.keys(zip.files).forEach((key) => {
	if(key.indexOf("overrides") != -1) {
		var slicedkey = key.slice("overrides".length);
		if(slicedkey.slice(-1) == "/") {
			if(!fs.existsSync(downloadDir + slicedkey)) {
				try {
					fs.mkdirSync(downloadDir + slicedkey);
				} catch {
				}
			}
			return;
		}
		console.log("Writing " + downloadDir + slicedkey + "...");
		fs.writeFileSync(downloadDir + slicedkey, zip.files[key]._data, 'binary');
	}
});
